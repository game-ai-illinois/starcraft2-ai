.TH "pysc2.bin.replay_actions" 3 "Fri Sep 28 2018" "UIUCscaipy2" \" -*- nroff -*-
.ad l
.nh
.SH NAME
pysc2.bin.replay_actions
.SH SYNOPSIS
.br
.PP
.SS "Classes"

.in +1c
.ti -1c
.RI "class \fBProcessStats\fP"
.br
.ti -1c
.RI "class \fBReplayProcessor\fP"
.br
.ti -1c
.RI "class \fBReplayStats\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "def \fBsorted_dict_str\fP (d)"
.br
.ti -1c
.RI "def \fBvalid_replay\fP (info, ping)"
.br
.ti -1c
.RI "def \fBstats_printer\fP (stats_queue)"
.br
.ti -1c
.RI "def \fBreplay_queue_filler\fP (replay_queue, replay_list)"
.br
.ti -1c
.RI "def \fBmain\fP (unused_argv)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "\fBFLAGS\fP = flags\&.FLAGS"
.br
.ti -1c
.RI "\fBsize\fP = point\&.Point(16, 16)"
.br
.ti -1c
.RI "\fBinterface\fP"
.br
.in -1c
.SH "Function Documentation"
.PP 
.SS "def pysc2\&.bin\&.replay_actions\&.main ( unused_argv)"

.PP
.nf
Dump stats about all the actions that are in use in a set of replays.
.fi
.PP
 
.SS "def pysc2\&.bin\&.replay_actions\&.replay_queue_filler ( replay_queue,  replay_list)"

.PP
.nf
A thread that fills the replay_queue with replay filenames.
.fi
.PP
 
.SS "def pysc2\&.bin\&.replay_actions\&.sorted_dict_str ( d)"

.SS "def pysc2\&.bin\&.replay_actions\&.stats_printer ( stats_queue)"

.PP
.nf
A thread that consumes stats_queue and prints them every 10 seconds.
.fi
.PP
 
.SS "def pysc2\&.bin\&.replay_actions\&.valid_replay ( info,  ping)"

.PP
.nf
Make sure the replay isn't corrupt, and is worth looking at.
.fi
.PP
 
.SH "Variable Documentation"
.PP 
.SS "pysc2\&.bin\&.replay_actions\&.FLAGS = flags\&.FLAGS"

.SS "pysc2\&.bin\&.replay_actions\&.interface"
\fBInitial value:\fP
.PP
.nf
1 =  sc_pb\&.InterfaceOptions(
2     raw=True, score=False,
3     feature_layer=sc_pb\&.SpatialCameraSetup(width=24))
.fi
.SS "pysc2\&.bin\&.replay_actions\&.size = point\&.Point(16, 16)"

.SH "Author"
.PP 
Generated automatically by Doxygen for UIUCscaipy2 from the source code\&.
